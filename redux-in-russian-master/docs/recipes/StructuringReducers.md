# Структурирование редюсеров

В основе своей, Redux следует достаточно простой концепции: вся ваша логика "записи" находится в одной функции, а единственный способ её вызвать - это дать Redux простой объект, объясняющий, что что-то произошло. Хранилище Redux запускает функцию с логикой записи, передавая её текущее дерево состояния и объект описания; на основании этого функция возвращает новое состояние, а Redux информирует подписчиков, что оно изменилось.

Redux накладывает некоторые базовые ограничения на то, как именно должна работать функция записи. Как описано в разделе [Редюсеры](../basics/Reducers.md), она обязана иметь сигнатуру `(previousState, action) => newState` (**сигнатура редюсера**), должна быть *чистой* и предсказуемой.

Для Redux совершенно не важно, как именно реализована ваша редюсер-функция, если она следует правилам, описанным выше. Это даёт нам свободу действий, но, в то же время, может стать источником беспорядка. В связи с этим, существует несколько широко используемых паттернов написания редюсеров, а также множество связанных с ними тем и вещей, которых стоит опасаться. С ростом приложения, эти паттерны сыграют ключевую роль в управлении сложностью кода редюсеров, обработке реальных данных и оптимизации производительности UI.


### Базовые концепции написания редюсеров

Некоторые из этих концепций уже были описаны в других частях документации Redux, другие же являются общеупотребимыми, и могут быть применены не только в Redux. Написано множество статей, которые в деталях рассказывают об их использовании. Эти техники и концепции формируют базу для написания качественной логики редюсеров Redux.

Важно, чтобы вы **действительно поняли** эти базовые концепции перед тем, как двигаться к более сложным и Redux-специфичным. Рекомендуемый их список их находится здесь:
#### [Базовые концепции](./reducers/PrerequisiteConcepts.md)  
  
Также важно отметить, что некоторые из этих концепций могут быть неприменимы в связи с архитектурными особенностями приложения. Например, приложение, использующее Maps из Immutable.js для хранения данных, почти наверняка будет иметь отличающуюся логику редюсеров от случая, когда используются нативные объекты JavaScript. Эта документация, в основном, предполагает использование объектов JavaScript, но многие принципы будут применимы и с другими инструментами.
  
  
  
### Концепции и техники написания редюсеров

- [Базовая структура редюсера](./reducers/BasicReducerStructure.md)
- [Разделение логики редюсеров](./reducers/SplittingReducerLogic.md)
- [Пример рефакторинга логики редюсеров](./reducers/RefactoringReducersExample.md)
- [Использование `combineReducers`](./reducers/UsingCombineReducers.md)
- [Редюсеры без `combineReducers`](./reducers/BeyondCombineReducers.md)
- [Нормализация состояния](./reducers/NormalizingStateShape.md)
- [Обновление нормализованных данных](./reducers/UpdatingNormalizedData.md)
- [Переиспользование логики редюсеров](./reducers/ReusingReducerLogic.md)
- [Паттерны иммутабельного обновления](./reducers/ImmutableUpdatePatterns.md)
- [Инициализация состояния](./reducers/InitializingState.md)
